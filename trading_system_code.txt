Fixes to apply (hand to Cursor)

A) Enforce “spot only” shorts (no net negative BTC)

Goal: When signal=short, sell up to current BTC balance, never more.

Add a flag and cap qty in orb_executor.py before placing the order:

# env / defaults
SPOT_ONLY = bool_from_env("SPOT_ONLY", True)
SAFETY_BAL_BUF = float_from_env("SAFETY_BAL_BUF", 0.995)  # keep a tiny dust buffer

def execute_orb_entry(dir_: str, entry_price: float, stop: float, desired_qty: float):
    side = "buy" if dir_ == "long" else "sell"

    # fetch balances once
    bals = get_balances_sanitized()  # returns {"btc": float, "usd": float, ...}
    btc_bal = float(bals.get("btc", 0.0))
    usd_bal = float(bals.get("usd", 0.0))

    qty = desired_qty

    if SPOT_ONLY and side == "sell":
        # Cap sell size to available BTC; never short
        max_sell = max(0.0, btc_bal * SAFETY_BAL_BUF)
        qty = min(qty, max_sell)

        if qty <= MIN_LOT_SIZE:   # use pair meta min lot
            log_skip("no_inventory", extra={"btc_bal": btc_bal})
            return {"status": "skipped", "reason": "no_inventory", "btc_bal": btc_bal}

    if SPOT_ONLY and side == "buy":
        # Optional: cap buy by available USD (avoid Kraken “insufficient funds”)
        notional = qty * entry_price
        max_notional = usd_bal * SAFETY_BAL_BUF
        if notional > max_notional:
            qty = max_notional / entry_price

        if qty <= MIN_LOT_SIZE:
            log_skip("insufficient_usd", extra={"usd_bal": usd_bal})
            return {"status": "skipped", "reason": "insufficient_usd", "usd_bal": usd_bal}

    # proceed with maker-first place + fallback
    return place_with_retries(side=side, qty=qty, price=entry_price)

#Also add a clear metric/log when a short is skipped due to no inventory:#

INFO:orb_executor:ORB_SKIP reason=no_inventory btc_bal=...

Config (defaults):

SPOT_ONLY=true

B) Make /pnl_summary always return numbers (never null)

def _safe_float(v, d=0.0):
    try: return float(v)
    except: return d

@app.get("/pnl_summary")
def pnl_summary():
    px = get_cached_price()  # from price worker
    bals = get_balances_sanitized()  # {"btc":..., "usd":..., "gbp":...}
    btc = _safe_float(bals.get("btc"))
    usd = _safe_float(bals.get("usd"))
    equity = usd + btc * px
    exposure_value = btc * px
    exposure_pct = 0.0 if equity <= 0 else exposure_value / equity

    return {
        "equity": round(equity, 2),
        "realized_pnl": _safe_float(get_realized_pnl()),
        "unrealized_pnl": round(0.0, 2),  # spot-only simple version
        "exposure_value": round(exposure_value, 2),
        "exposure_pct": round(exposure_pct, 4),
        "price": px,
        "status": "ok",
    }

This will make the UI tiles populate, and it’s cheap (no LLM call).

